---
title: Build and send a Transaction
description: How to prepare and send a transaction with the Flow python SDK
contentType: HOWTO
---

Flow, like most blockchains, allows anybody to submit a transaction that mutates
the shared global chain state. A transaction is an object that holds a payload,
which describes the state mutation, and one or more authorizations that permit
the transaction to mutate the state owned by specific accounts.

You can read more about transactions in the [transaction lifecycle documentation](/concepts/transaction-lifecycle).

A transaction contains the following fields:

- `script` - Raw source code for a Cadence script, encoded as UTF-8 bytes
- `arguments` - Arguments passed to the Cadence script, encoded as JSON-Cadence bytes
- `reference_block_id` - Block ID used to determine transaction expiry
- `proposal_key` - Account key used to propose the transaction
- `payer` - Address of the payer account
- `authorizers` - Addresses of the transaction authorizers
- `signatures` - Signatures from all signer accounts

# Create the Transaction

A transaction needs some parameters, first have a look on them then implement them in example.

You can start by creating an empty transaction with the python SDK.
We'll populate the remaining fields one by one.

## Code

The `code` field is the portion of the transaction that describes the state mutation logic.

On Flow, transaction logic is written in [Cadence](/cadence). The value of `code`
is a byte slice containing the UTF-8 encoded source code for a Cadence program.


## Gas Limit

A transaction must specify a limit on the amount of computation it requires,
referred to as the _gas limit_. A transaction will abort if it exceeds its gas limit.

### How is gas measured?

Cadence uses metering to measure the number of operations per transaction.
You can read more about it in the [Cadence documentation](/cadence).

### What should the limit be?

The gas limit depends on the complexity of the transaction script.
Until dedicated gas estimation tooling exists, it's best to use the emulator
to test complex transactions and determine a safe limit.

## Reference Block

A transaction must specify an expiration window (measured in blocks) during which it is considered valid by the network.
A transaction will be rejected if it is submitted past its expiry block.

## Proposal Key

A transaction must specify a [sequence number](/concepts/transaction-signing/#sequence-numbers)
to prevent replays and other potential attacks.

Each account key maintains a separate transaction sequence counter;
the key that lends its sequence number to a transaction is called the _proposal key_.

A proposal key contains three fields:

- Account address
- Key index
- Sequence number

A transaction is only valid if its declared sequence number matches the current
on-chain sequence number for that key. The sequence number increments by one after
the transaction is executed.

## Payer

The transaction payer is the account that pays the fees for the transaction.
A transaction must specify exactly one payer. The payer is only responsible
for paying the network and gas fees; the transaction is not authorized to access
resources or code stored in the payer account.

From what you learn so far now you can create a transaction as below:

```python
async def run(self, ctx: Config):
    # First Step : Create a client to connect to the flow blockchain
    # flow_client function creates a client using the host and port
    account_key, new_signer = AccountKey.from_seed(seed = "dfghj dfj kjhgf hgfd lkjhgf kjhgfd sdfghjkl")

    async with flow_client(
            host=ctx.access_node_host, port=ctx.access_node_port
        ) as client:
            latest_block = await client.get_latest_block()
            proposer = await client.get_account_at_latest_block(address = ctx.service_account_address)

            tx = Tx(
                code="""transaction(){prepare(){log("OK")}}""",
                reference_block_id = latest_block.id,
                payer = account_key.public_key,
                proposal_key = ProposalKey(
                    key_address = account_key.public_key,
                    key_id = 0,
                    key_sequence_number = proposer.keys[
                        0
                    ].sequence_number,
                ),
            )
```
There is more you can do with transaction. let's check them:

## Arguments

A transaction can accept zero or more arguments that are passed into the Cadence script.

The arguments on the transaction must match the number and order declared in
the Cadence script.

```python
tx.add_arguments("argument1")
```

## Authorizers

An authorizer is an account that authorizes a transaction to read and mutate its resources.
A transaction can specify zero or more authorizers,
depending on how many accounts the transaction needs to access.

The number of authorizers on the transaction must match the number of `AuthAccount`
parameters declared in the `prepare` statement of the Cadence script.

```python
  tx.add_authorizers(authorizerAddress)
}
```
# Sign a transaction

Transaction signing is done through the `Signer`. The simplest
(and least secure) implementation of `Signer` is `InMemorySigner`.

Signatures can be generated more securely using keys stored in a hardware device such
as an [HSM](https://en.wikipedia.org/wiki/Hardware_security_module).

```python
signer = in_memory_signer.InMemorySigner(hash_algo =  hash_algo,
        sign_algo = sign_algo,
        private_key_hex = private_key.to_string().hex())

tx.with_envelope_signature(
                    account_key.public_key,
                    0,
                    new_signer,
                )
```

# How Signatures Work in Flow

Flow introduces new concepts that allow for more flexibility when creating and signing transactions.

---

## Single party, single signature

- Proposer, payer and authorizer are the same account (`0x01`).
- Only the envelope must be signed.
- Proposal key must have full signing weight.

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| `0x01`  | 1      | 1.0    |

```python
async def run(self, ctx: Config):
    # First Step : Create a client to connect to the flow blockchain
    # flow_client function creates a client using the host and port
    address = Address.from_hex("0x01")
    account = await client.get_account(address = address)
    # Assume you stored private key somewhere safe and restore it in private_key.
    signer = in_memory_signer.InMemorySigner(hash_algo =  hash_algo,
        sign_algo = sign_algo,
        private_key_hex = private_key.to_string().hex())
    async with flow_client(
            host=ctx.access_node_host, port=ctx.access_node_port
        ) as client:
            latest_block = await client.get_latest_block()
            
            tx = Tx(
                code="""
                        transaction {
                            prepare(signer: AuthAccount) { log(signer.address) }
                        }
                    """,
                reference_block_id = latest_block.id,
                payer = account.address,
                proposal_key = ProposalKey(
                    key_address = account.address,
                    key_id = 0,
                    key_sequence_number = account.keys[
                        0
                    ].sequence_number,
                ),
            ).add_authorizers([account.address])
            .with_envelope_signature(
                account.address,
                0,
                signer,
            )
```
---

## Single party, multiple signatures

- Proposer, payer and authorizer are the same account (`0x01`).
- Only the envelope must be signed.
- Each key has weight 0.5, so two signatures are required.

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| `0x01`  | 1      | 0.5    |
| `0x01`  | 2      | 0.5    |

```python
async def run(self, ctx: Config):
    # First Step : Create a client to connect to the flow blockchain
    # flow_client function creates a client using the host and port
    address = Address.from_hex("0x01")
    account = await client.get_account(address = address)
    # Assume you stored private key somewhere safe and restore it in private_key.
    signer1 = in_memory_signer.InMemorySigner(hash_algo =  hash_algo,
        sign_algo = sign_algo,
        private_key_hex = private_key1.to_string().hex())
    signer2 = in_memory_signer.InMemorySigner(hash_algo =  hash_algo,
        sign_algo = sign_algo,
        private_key_hex = private_key2.to_string().hex())
    async with flow_client(
            host=ctx.access_node_host, port=ctx.access_node_port
        ) as client:
            latest_block = await client.get_latest_block()
            
            tx = Tx(
                code="""
                        transaction {
                            prepare(signer: AuthAccount) { log(signer.address) }
                        }
                    """,
                reference_block_id = latest_block.id,
                payer = account.address,
                proposal_key = ProposalKey(
                    key_address = account.address,
                    key_id = 0,
                    key_sequence_number = account.keys[
                        0
                    ].sequence_number,
                ),
            ).add_authorizers([account.address])
            .with_envelope_signature(
                account.address,
                0,
                signer1,
            ).with_envelope_signature(
                account.address,
                1,
                signer2,
            )
```

---

## Multiple parties

- Proposer and authorizer are the same account (`0x01`).
- Payer is a separate account (`0x02`).
- Account `0x01` signs the payload.
- Account `0x02` signs the envelope.
  - Account `0x02` must sign last since it is the payer.

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| `0x01`  | 1      | 1.0    |
| `0x02`  | 3      | 1.0    |

```python
async def run(self, ctx: Config):
    # First Step : Create a client to connect to the flow blockchain
    # flow_client function creates a client using the host and port
    address1 = Address.from_hex("0x01")
    address3 = Address.from_hex("0x02")
    account = await client.get_account(address = address)
    # Assume you stored private key somewhere safe and restore it in private_key.
    signer1 = in_memory_signer.InMemorySigner(hash_algo =  hash_algo,
        sign_algo = sign_algo,
        private_key_hex = private_key1.to_string().hex())
    signer3 = in_memory_signer.InMemorySigner(hash_algo =  hash_algo,
        sign_algo = sign_algo,
        private_key_hex = private_key3.to_string().hex())
    async with flow_client(
            host=ctx.access_node_host, port=ctx.access_node_port
        ) as client:
            latest_block = await client.get_latest_block()
            
            tx = Tx(
                code="""
                        transaction {
                            prepare(signer: AuthAccount) { log(signer.address) }
                        }
                    """,
                reference_block_id = latest_block.id,
                payer = account3.address,
                proposal_key = ProposalKey(
                    key_address = account1.address,
                    key_id = 0,
                    key_sequence_number = account.keys[
                        0
                    ].sequence_number,
                ),
            ).add_authorizers([account1.address])
            .with_payload_signature(
                account1.address,
                0,
                signer1,
            ).with_envelope_signature(
                account3.address,
                0,
                signer3,
            )
```
---

## Multiple parties, two authorizers

- Proposer and authorizer are the same account (`0x01`).
- Payer is a separate account (`0x02`).
- Account `0x01` signs the payload.
- Account `0x02` signs the envelope.
  - Account `0x02` must sign last since it is the payer.
- Account `0x02` is also an authorizer to show how to include two AuthAccounts into an transaction

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| `0x01`  | 1      | 1.0    |
| `0x02`  | 3      | 1.0    |

```python
async def run(self, ctx: Config):
    # First Step : Create a client to connect to the flow blockchain
    # flow_client function creates a client using the host and port
    address1 = Address.from_hex("0x01")
    address3 = Address.from_hex("0x02")
    account = await client.get_account(address = address)
    # Assume you stored private key somewhere safe and restore it in private_key.
    signer1 = in_memory_signer.InMemorySigner(hash_algo =  hash_algo,
        sign_algo = sign_algo,
        private_key_hex = private_key1.to_string().hex())
    signer3 = in_memory_signer.InMemorySigner(hash_algo =  hash_algo,
        sign_algo = sign_algo,
        private_key_hex = private_key3.to_string().hex())
    async with flow_client(
            host=ctx.access_node_host, port=ctx.access_node_port
        ) as client:
            latest_block = await client.get_latest_block()
            
            tx = Tx(
                code="""
                        transaction {
                            prepare(signer: AuthAccount) { log(signer.address) }
                        }
                    """,
                reference_block_id = latest_block.id,
                payer = account3.address,
                proposal_key = ProposalKey(
                    key_address = account1.address,
                    key_id = 0,
                    key_sequence_number = account.keys[
                        0
                    ].sequence_number,
                ),
            ).add_authorizers([account1.address, account3.address])
            .with_payload_signature(
                account1.address,
                0,
                signer1,
            ).with_envelope_signature(
                account3.address,
                0,
                signer3,
            )
```

---

## Multiple parties, multiple signatures

- Proposer and authorizer are the same account (`0x01`).
- Payer is a separate account (`0x02`).
- Account `0x01` signs the payload.
- Account `0x02` signs the envelope.
  - Account `0x02` must sign last since it is the payer.
- Both accounts must sign twice (once with each of their keys).

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| `0x01`  | 1      | 0.5    |
| `0x01`  | 2      | 0.5    |
| `0x02`  | 3      | 0.5    |
| `0x02`  | 4      | 0.5    |

```python
async def run(self, ctx: Config):
    # First Step : Create a client to connect to the flow blockchain
    # flow_client function creates a client using the host and port
    address1 = Address.from_hex("0x01")
    address3 = Address.from_hex("0x02")
    account = await client.get_account(address = address)
    # Assume you stored private key somewhere safe and restore it in private_key.
    signer1 = in_memory_signer.InMemorySigner(hash_algo =  hash_algo,
        sign_algo = sign_algo,
        private_key_hex = private_key1.to_string().hex())
    signer2 = in_memory_signer.InMemorySigner(hash_algo =  hash_algo,
        sign_algo = sign_algo,
        private_key_hex = private_key2.to_string().hex())
    signer3 = in_memory_signer.InMemorySigner(hash_algo =  hash_algo,
        sign_algo = sign_algo,
        private_key_hex = private_key3.to_string().hex())
    signer4 = in_memory_signer.InMemorySigner(hash_algo =  hash_algo,
        sign_algo = sign_algo,
        private_key_hex = private_key4.to_string().hex())
    async with flow_client(
            host=ctx.access_node_host, port=ctx.access_node_port
        ) as client:
            latest_block = await client.get_latest_block()
            
            tx = Tx(
                code="""
                        transaction {
                            prepare(signer: AuthAccount) { log(signer.address) }
                        }
                    """,
                reference_block_id = latest_block.id,
                payer = account2.address,
                proposal_key = ProposalKey(
                    key_address = account1.address,
                    key_id = 0,
                    key_sequence_number = account.keys[
                        0
                    ].sequence_number,
                ),
            ).add_authorizers([account1.address])
            .with_payload_signature(
                account1.address,
                0,
                signer1,
            ).with_payload_signature(
                account1.address,
                1,
                signer2,
            ).with_envelope_signature(
                account3.address,
                0,
                signer3,
            ).with_envelope_signature(
                account3.address,
                1,
                signer4,
            )
```

# Send transaction and get results

There is two way to do this:
- you can use `send_transaction` and `get_transaction_result`.
- you can use `execute_transaction`

The second one is recommanded. you can see a example in below:

```python
results = await client.execute_transaction(tx)
```
